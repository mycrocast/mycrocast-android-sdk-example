<!DOCTYPE html>
<html class="no-js">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>Mycrocast SDK</title>
    <link href="images/logo-icon.svg" rel="icon" type="image/svg">
    <script>var pathToRoot = "";</script>
    <script>document.documentElement.classList.replace("no-js","js");</script>
    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script type="text/javascript" src="https://unpkg.com/kotlin-playground@1/dist/playground.min.js" async="async"></script>
<script type="text/javascript" src="scripts/sourceset_dependencies.js" async="async"></script>
<link href="styles/style.css" rel="Stylesheet">
<link href="styles/main.css" rel="Stylesheet">
<link href="styles/prism.css" rel="Stylesheet">
<link href="styles/logo-styles.css" rel="Stylesheet">
<link href="styles/font-jb-sans-auto.css" rel="Stylesheet">
<link href="ui-kit/ui-kit.min.css" rel="Stylesheet">
<script type="text/javascript" src="scripts/clipboard.js" async="async"></script>
<script type="text/javascript" src="scripts/navigation-loader.js" async="async"></script>
<script type="text/javascript" src="scripts/platform-content-handler.js" async="async"></script>
<script type="text/javascript" src="scripts/main.js" defer="defer"></script>
<script type="text/javascript" src="scripts/prism.js" async="async"></script>
<script type="text/javascript" src="ui-kit/ui-kit.min.js" defer="defer"></script>
<script type="text/javascript" src="scripts/symbol-parameters-wrapper_deferred.js" defer="defer"></script>
</head>
<body>
    <div class="root">
    <nav class="navigation theme-dark" id="navigation-wrapper">
            <a class="library-name--link" href="index.html">
                    Mycrocast SDK
            </a>
        <button class="navigation-controls--btn navigation-controls--btn_toc ui-kit_mobile-only" id="toc-toggle"
                type="button">Toggle table of contents
        </button>
        <div class="navigation-controls--break ui-kit_mobile-only"></div>
        <div class="library-version" id="library-version">
v1.3.4        </div>
        <div class="navigation-controls">
        <div class="filter-section filter-section_loading" id="filter-section">
                <button class="platform-tag platform-selector jvm-like" data-active=""
                        data-filter=":library/release">androidJvm</button>
            <div class="dropdown filter-section--dropdown" data-role="dropdown" id="filter-section-dropdown">
                <button class="button button_dropdown filter-section--dropdown-toggle" role="combobox"
                        data-role="dropdown-toggle"
                        aria-controls="platform-tags-listbox"
                        aria-haspopup="listbox"
                        aria-expanded="false"
                        aria-label="Toggle source sets"
                ></button>
                <ul role="listbox" id="platform-tags-listbox" class="dropdown--list" data-role="dropdown-listbox">
                    <div class="dropdown--header"><span>Platform filter</span>
                        <button class="button" data-role="dropdown-toggle" aria-label="Close platform filter">
                            <i class="ui-kit-icon ui-kit-icon_cross"></i>
                        </button>
                    </div>
                        <li role="option" class="dropdown--option platform-selector-option jvm-like" tabindex="0">
                            <label class="checkbox">
                                <input type="checkbox" class="checkbox--input" id=":library/release"
                                       data-filter=":library/release"/>
                                <span class="checkbox--icon"></span>
                                androidJvm
                            </label>
                        </li>
                </ul>
                <div class="dropdown--overlay"></div>
            </div>
        </div>
            <button class="navigation-controls--btn navigation-controls--btn_theme" id="theme-toggle-button"
                    type="button">Switch theme
            </button>
            <div class="navigation-controls--btn navigation-controls--btn_search" id="searchBar" role="button">Search in
                API
            </div>
        </div>
    </nav>
        <div id="container">
            <div class="sidebar" id="leftColumn">
                <div class="dropdown theme-dark_mobile" data-role="dropdown" id="toc-dropdown">
                    <ul role="listbox" id="toc-listbox" class="dropdown--list dropdown--list_toc-list"
                        data-role="dropdown-listbox">
                        <div class="dropdown--header">
                            <span>
                                    Mycrocast SDK
                            </span>
                            <button class="button" data-role="dropdown-toggle" aria-label="Close table of contents">
                                <i class="ui-kit-icon ui-kit-icon_cross"></i>
                            </button>
                        </div>
                        <div class="sidebar--inner" id="sideMenu"></div>
                    </ul>
                    <div class="dropdown--overlay"></div>
                </div>
            </div>
            <div id="main">
<div class="main-content" id="content" pageIds="Mycrocast SDK::////PointingToDeclaration//1203251188">
  <div class="breadcrumbs"></div>
  <div class="cover ">
    <h1 class="cover"><span><span>Mycrocast</span></span> <span><span>SDK</span></span></h1>
    <div class="platform-hinted UnderCoverText" data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":library/release"><h1 class="">MycrocastSDK - Android</h1><h1 class="">1. General</h1><p class="paragraph">A General description about some concepts for the mycrocast SDK.</p><h1 class="">Version History</h1><p class="paragraph">The following will describe what has changed in the different versions of the sdk.</p><h2 class="">Version 1.34</h2><h3 class="">Support</h3><p class="paragraph">Added support for 16 KB page sizes.</p><h2 class="">Version 1.33</h2><h3 class="">Optimization</h3><p class="paragraph">Reworked the synchronize (buffer & delay) feature internal inside the sdk for better audio quality, which fixes audio stutter occurring on some mobile devices.</p><h2 class="">Version 1.32</h2><p class="paragraph">You can now check whether at least one livestream is online for your club without the need to initialize the sdk itself.</p><h3 class="">New feature: Livestream availability check</h3><p class="paragraph">Added LivestreamAvailabilityChecker, which can check if at least one livestream is active from the customer (via their customer token) without initializing the SDK itself.</p><h2 class="">Version 1.31</h2><h3 class="">Bugfixes</h3><p class="paragraph">Spots which are send by our backend server are now serialized correctly Mute music is not playing twice, if the streamer is streaming from our mycrocast-studio platform</p><h2 class="">Version 1.3.0</h2><p class="paragraph">You can now configure buffering as well as delay within the sdk.</p><h3 class="">New Feature: Buffering</h3><p class="paragraph">Buffering describes the amount of seconds of audio data that are collected before the first audio package is transmitted from the sdk for playback.</p><p class="paragraph">Disabling buffering has the potential to negatively affect the listener as more stops/artifacts within the audio transmission can be heard in case of changing network conditions. Setting the buffering to a too high value, will lead to a long wait time, until the first audio is heard. Something between 2s-5s could be a good measure.</p><h3 class="">New Feature: Delay</h3><p class="paragraph">The delay functionality enables the user to somewhat sync any tv screen picture with the heard audio. Normally the audio is quite far ahead when you compare it to internet tv transmissions (sometimes more than 2 minutes).</p><p class="paragraph">We internally store the audio packages so that the user can jump back in time or delay the audio transmission to match the screen. You need to configure a max delay, this is the amount of audio packages we keep internally available.</p><p class="paragraph">A good measure is between 3-5 minutes. Setting it too high could lead to memory issues, as this is all kept in memory.</p><p class="paragraph">When a delay is configured, all events are also processed delayed. Meaning, that for example you have 30s delay configured and receive a push to play an advertisement. This push is also delayed 30s. Of any delayed events are &quot;queued&quot; and the user decided to reduce the delay, (basically jumping ahead in time) the events are triggered at the specific time.</p><p class="paragraph">It is a good idea to provide the user with some user interface, where the user can jump more than 1s (maybe buttons like 1s,5s, 30s).</p><h3 class="">Breaking changes</h3><p class="paragraph">Due to consistency AdvertisementPlay was renamed to SpotPlay and AdvertisementBanner to SpotBanner.</p><h1 class="">General requirements</h1><h2 class="">Request limit</h2><p class="paragraph">To provide a smooth user experience we have rate limits in place to avoid burst scenarios affecting the overall system. As the system is scaling based on load, the rate limits are also dynamically but are initially coming from a no load scenario at around 10000 request/minute. Only the isClubLive() method of the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.checker.domain/-livestream-availability-checker/index.html">LivestreamAvailabilityChecker</a> has higher limits. Please structure the implementation accordingly. Not every user of the app should init the SDK, just users that are in the audio area.</p><h2 class="">Open ports</h2><p class="paragraph">To be able to test and depending on your internal setup regarding ports, the following ports must be open:</p><ul><li><p class="paragraph">8080</p></li><li><p class="paragraph">10011</p></li><li><p class="paragraph">20022</p></li><li><p class="paragraph">8001</p></li><li><p class="paragraph">8000</p></li><li><p class="paragraph">7777</p></li></ul><h1 class="">SDK Concepts</h1><p class="paragraph">Description of some concepts and workflows that are independent of the SDK platform as well as design goals for the SDK are described below</p><h2 class="">Flexibility</h2><p class="paragraph">The SDK is build with the goal to provide the most flexibility for the developers side to adjust and implement as required from their side.There are no provided visual elements, these need to be developed by the implementing side to fit them natively into the app.</p><p class="paragraph">To further increase the flexibility we only pass most of the events to the developer to react on them. This has the drawback that the development effort is a bit higher on their side but enables custom features that otherwise would not be possible.</p><p class="paragraph">Both the iOS and Android SDK are accompanied by an example app demonstrating each aspect of the SDK and also example implementations for visual elements and other workflow related concepts like playing the actual audio.</p><h2 class="">Audio</h2><p class="paragraph">The audio is provided based on the platform directly as playable audio packages or just bytes. The audio playback needs to be implemented by the developing side. The received audio is already decoded.</p><p class="paragraph">The audio is 48000khz 16 bit pcm data with 960 frames (1920 bytes).</p><h2 class="">Streams</h2><p class="paragraph">A stream represents a live transmission that was started from within the mycrocast app. There can be multiple streamers online for you club, depending on how many users were created. This could for example be the case if you want to provide coverage of a game in different languages.</p><h3 class="">Stream types</h3><p class="paragraph">There are in general 2 distinct types of stream that can be configured from the streamer side.</p><h4 class="">General Stream</h4><p class="paragraph">This is a general stream, not necessary belonging to a game transmission. This is usually used for press conferences, interview or anything that is not a sport event.</p><h4 class="">Scoring/Sport Event</h4><p class="paragraph">This kind of stream is normally used during a game as it contains the 2 teams playing and also the current scoring of the 2 teams.The streamer can update the score per team and this is also propagated through the system.</p><h3 class="">Updates</h3><p class="paragraph">A stream is updated in regular intervals and these updates are propagated through the SDK. Not every user starting to listen will update the listener count. Updates are provided on a short time interval.</p><h3 class="">Mute Streams</h3><p class="paragraph">A streamer can mute himself during the transmission (for example within the break). During this time there will be a mute music that is provided by the SDK. It just needs to be played from the developer side. The SDK only provides the remote URL to be played from. If you actually want to play the mute music is up to you</p><h3 class="">Rating of a stream</h3><p class="paragraph">Each user can rate a stream. Either up- or down vote a livestream or remove a previous vote.</p><h3 class="">Buffering</h3><p class="paragraph">Buffering describes the amount of seconds of audio data that are collected before the first audio package is transmitted from the sdk for playback.</p><p class="paragraph">Disabling buffering has the potential to negatively affect the listener as more stops/artifacts within the audio transmission can be heard in case of changing network conditions. Setting the buffering to a too high value, will lead to a long wait time, until the first audio is heard. Something between 2s-5s could be a good measure.</p><h3 class="">Delay</h3><p class="paragraph">The delay functionality enables the user to somewhat sync any tv screen picture with the heard audio. Normally the audio is quite far ahead when you compare it to internet tv transmissions (sometimes more than 2 minutes).</p><p class="paragraph">We internally store the audio packages so that the user can jump back in time or delay the audio transmission to match the screen. You need to configure a max delay, this is the amount of audio packages we keep internally available.</p><p class="paragraph">A good measure is between 3-5 minutes. Setting it too high could lead to memory issues, as this is all kept in memory.</p><p class="paragraph">When a delay is configured, all events are also processed delayed. Meaning, that for example you have 30s delay configured and receive a push to play an advertisement. This push is also delayed 30s. Of any delayed events are &quot;queued&quot; and the user decided to reduce the delay, (basically jumping ahead in time) the events are triggered at the specific time.</p><p class="paragraph">It is a good idea to provide the user with some user interface, where the user can jump more than 1s (maybe buttons like 1s,5s, 30s).</p><h2 class="">Advertisements</h2><p class="paragraph">When an advertisement is available to play, an event is triggered based on the platform. The developer can decide if the ad should actually be played or can be ignored.</p><p class="paragraph">An advertisement can contain a short description (which service or product this ad is for), and besides the audio file an optional image to display going along with the audio.</p><h3 class="">Playing an advertisement</h3><p class="paragraph">The SDK only informs you that an advertisement is available to be played. The developer decides if the advertisement should actually be played or ignored. This provides maximal flexibility for the implementing side.</p><h3 class="">PreStream Advertisements</h3><p class="paragraph">During the connection to a live stream the SDK can respond with an advertisement if the user did not receive an ad play within a certain time span. A pre stream advertisement is treated like a normal advertisement. The system just informs you that a new advertisement is available for playing.</p><h3 class="">InStream Advertisements</h3><p class="paragraph">During the broadcast the streamer can decide at which points to trigger an advertisement. There are no fixed intervals at which ads are played. The streamer is in complete control of how many and what ads are going to be played.</p><h2 class="">Chat</h2><p class="paragraph">For each stream there exists a chatroom. A chatroom is either enabled or disabled and the status of the chatroom can change during the stream as the streamer is in control over the status of the chat.</p><p class="paragraph">Users of the SDK and registered mycrocast app users can participate in the chat. A user can be blocked from the chat though the streamer only. Even if the user is blocked the SDK does not prevent the user from sending a message, it will just not be displayed for other users.</p><p class="paragraph">The SDK provides the information if a user is blocked but it is up to the developer to either display that information or not.</p><h1 class="">2. Android SDK</h1><h2 class="">Getting started</h2><p class="paragraph">To get started with the sdk the following steps are required.</p><h3 class="">1. Importing the library to your application</h3><h4 class="">1.1 Adding the maven repository (as gradle-import)</h4><p class="paragraph">This is the url of the maven repository for the mycrocast android SDK:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">https://mycrocast-maven-repo.s3.eu-central-1.amazonaws.com </code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">You need to add the following to your build.gradle file of your project:</p><div class="sample-container"><pre><code class="block lang- java" theme="idea">//...<br><br>allprojects {  <br>	repositories {  <br>		//...<br><br>		maven {  <br>			url &quot;https://mycrocast-maven-repo.s3.eu-central-1.amazonaws.com&quot;  <br>		}  <br>	}<br>}<br> <br>//...</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">And you need to add the following to your build.gradle file of your module:</p><div class="sample-container"><pre><code class="block lang- java" theme="idea">dependencies {  <br><br>	//...<br><br>	implementation 'de.mycrocast.library:library:1.3.4'<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">The example application for importing the library with gradle can be found <a href="https://github.com/mycrocast/mycrocast-android-sdk-example">here</a>.</p><h4 class="">1.2 Manually adding as aar library</h4><p class="paragraph">If you cannot use the maven approach above and need the aar file. Get in touch with us!</p><h3 class="">2. Permissions</h3><p class="paragraph">This SDK needs to communicate with the mycrocast backend-server via rest-communication, therefore you need to make sure you have the internet-permission in your AndroidManifest.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  <br>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;de.mycrocast.android.sdk.example&quot;&gt;  <br>	// ...<br>	<br>	&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;<br>	<br>	// ...</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">3. Initialising the sdk</h3><p class="paragraph">The first thing you need to do before you can use any other functionality than the LivestreamAvailabilityChecker of the sdk is to initialise it with your api key and your customer token. This can be done for example the onCreate of the Application class</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**<br> * Starting point of the application, also the point where we initialise the sdk<br> */<br>public class MycrocastExampleApplication extends Application {<br><br>    // replace with your api key<br>    private static final String MUSTER_API_KEY = &quot;YOUR_API_KEY&quot;;<br><br>    // replace with your customer token<br>    private static final String MUSTER_CUSTOMER_TOKEN = &quot;YOUR_CUSTOMER_TOKEN&quot;;<br><br>    // replace with the maximum number of seconds for the audio delay you want to support<br>    private static final int MAX_AUDIO_DELAY = 30;<br><br>    @Override<br>    public void onCreate() {<br>        super.onCreate();<br><br>        // check if a livestream of your club is currently online, can be done without initializing the sdk<br>        final LivestreamAvailabilityChecker checker = Mycrocast.getLivestreamAvailabilityChecker();<br>        checker.isClubLive(CUSTOMER_TOKEN, new LivestreamAvailabilityChecker.ResultCallback() {<br>            @Override<br>            public void onLivestreamAvailable() {<br>                System.out.println(&quot;At least one livestream is currently online for your club!&quot;);<br>            }<br><br>            @Override<br>            public void onNoLivestreamOnline() {<br>                System.out.println(&quot;No livestream online for your club.&quot;);<br>            }<br>        });<br><br>        // initialize the sdk with your credentials<br>        Mycrocast.initialize(API_KEY, CUSTOMER_TOKEN, PreferenceManager.getDefaultSharedPreferences(this), MAX_AUDIO_DELAY);<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">Getting familiar with the SDK</h2><h3 class="">1. Entry class of the SDK: Mycrocast</h3><p class="paragraph">The class Mycrocast, that only contains static methods, is your entry point into anything related to the Android mycrocast SDK.</p><p class="paragraph">It provides:</p><ul><li><p class="paragraph">initialisation of the SDK, including configuration of the maximum audio delay while playing a livestream</p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.checker.domain/-livestream-availability-checker/index.html">LivestreamAvailabilityChecker</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.container/-live-stream-container/index.html">LiveStreamContainer</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.refresh/-live-stream-refresher/index.html">LiveStreamRefresher</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.rating/-live-stream-rater/index.html">LiveStreamRater</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener.state/-live-stream-listener-state/index.html">LiveStreamListenerState</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener/-live-stream-listener-factory/index.html">LiveStreamListenerFactory</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat/-chat/index.html">Chat</a></p></li><li><p class="paragraph">access to the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.error/-error-receiving/index.html">ErrorReceiving</a></p></li><li><p class="paragraph">termination of the SDK</p></li></ul><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br> * Entry point to access the different parts of the android sdk. * The first step before anything else is done is to initialize the sdk with your customer credentials */public final class Mycrocast {  <br>  <br>    private static final SDKState state = new MycrocastSDKState();  <br>  <br>    /**  <br>     * Initialise the sdk with your customer information     <br>     *     <br>     * @param apiKey        - your api key  <br>     * @param customerToken - your customer token  <br>     * @param preferences   - android preferences  <br>     */    <br>     public static void initialize(String apiKey, String customerToken, SharedPreferences preferences) {  <br>        state.onInitialize(apiKey, customerToken, new SharedPreferenceStorage(preferences));  <br>    }  <br>  <br>    /**  <br>     * Initialise the sdk with your customer information     <br>     *     <br>     * @param apiKey        - your api key  <br>     * @param customerToken - your customer token  <br>     * @param preferences   - android preferences  <br>     * @param maxDelayInSeconds - maximum delay while playing a livestream in seconds  <br>     */    <br>     public static void initialize(String apiKey, String customerToken, SharedPreferences preferences, int maxDelayInSeconds) {  <br>        state.onInitialize(apiKey, customerToken, new SharedPreferenceStorage(preferences), maxDelayInSeconds);  <br>    }<br><br>    /**<br>     * Determines if at least one livestream for the club is online (true) or not (false).<br>     * No initializing of the SDK is needed for this method wot work.<br>     *<br>     * @return Whether at least one livestream is currently online or not.<br>     */<br>    @NonNull<br>    public static LivestreamAvailabilityChecker getLivestreamAvailabilityChecker() {<br>        return state.getLivestreamAvailabilityChecker();<br>    }<br>    <br>    /**  <br>     * @return the LiveStreamContainer to interact with the live streams  <br>     */    <br>    @NonNull  <br>    public static LiveStreamContainer getLiveStreamContainer() {  <br>        return state.getLiveStreamContainer();  <br>    }  <br>  <br>    /**  <br>     * Can only be null, if you did not initialize the sdk before accessing this.     <br>     *     <br>     * @return the live stream refresher  <br>     */    <br>    @Nullable  <br>    public static LiveStreamRefresher getLiveStreamRefresher() {  <br>        return state.getLiveStreamRefresher();  <br>    }  <br>  <br>    /**  <br>     * @return the live stream rater  <br>     */    <br>    @NonNull  <br>    public static LiveStreamRater getLiveStreamRater() {  <br>        return state.getLiveStreamRater();  <br>    }  <br>  <br>    /**  <br>     * @return the live stream listener state  <br>     */    <br>    @NonNull  <br>    public static LiveStreamListenerState getListenerState() {  <br>        return state.getListenerState();  <br>    }  <br>  <br>    /**  <br>     * Getter for the interaction for anything related to the chat     <br>     *     <br>     * @return - the chat interface  <br>     */    <br>    @NonNull  <br>    public static Chat getChat() {  <br>        return state.getChat();  <br>    }  <br>  <br>    /**  <br>     * @return the interface, that can be used for receiving error message provided by the sdk  <br>     */    <br>    @NonNull  <br>    public static ErrorReceiving getErrorReceiving() {  <br>        return state.getErrorReceiving();  <br>    }  <br>  <br>    /**  <br>     * Can only be null, if you did not initialize the sdk before accessing  this.     <br>     *     <br>     * @return the factory, that can be used for creating a LiveStreamListener for a specific livestream.  <br>     */    <br>    @Nullable  <br>    public static LiveStreamListenerFactory getLiveStreamListenerFactory() {  <br>        return state.getLiveStreamListenerFactory();  <br>    }  <br>  <br>    /**  <br>     * Terminates the sdk.     <br>     */    <br>    public static void terminate() {  <br>        state.onTerminate();  <br>    }  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">2. Requesting active livestreams, receiving updates for them</h3><p class="paragraph">As already described in the concept overview of the sdk, we can either have a general stream (normally used to broadcast something that is not directly tied to a match, like a press conference or an &quot;Ask me anything&quot; ...) consisting of a title and a description or a match (scoring) that has additional fields of the two teams playing, which have each a name and an actual scoring, which is updated by the streamer.</p><h2 class="">Relevant classes</h2><ul><li><p class="paragraph">Represents a single livestream: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data/-live-stream/index.html">LiveStream</a></p></li><li><p class="paragraph">Language of a livestream, configured by the streamer: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data.language/-stream-language/index.html">StreamLanguage</a></p></li><li><p class="paragraph">Will be a part of a livestream with a match, configured by the streamer: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data/-scoring/index.html">Scoring</a></p></li><li><p class="paragraph">Scoring includes two of them, configured by the streamer: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data.description/-team/index.html">Team</a></p></li><li><p class="paragraph">Getting the list of active livestreams, observing changes: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.container/-live-stream-container/index.html">LiveStreamContainer</a></p></li><li><p class="paragraph">Refreshing the list of active livestreams from the backend: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.refresh/-live-stream-refresher/index.html">LiveStreamRefresher</a></p></li></ul><h2 class="">Concepts</h2><h3 class="">Structure of a live stream</h3><p class="paragraph">Refer to the documentation about the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data/-live-stream/index.html">LiveStream</a> Check the hasScoring property to determine if the additional fields of the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data/-scoring/index.html">Scoring</a> are present.</p><h5 class="">Image resources</h5><p class="paragraph">The liveStream has an nullable field clubLogoUrl which contains the url to the configured image resource of the club (if any) the liveStream has an nullable field clubHeaderUrl which contains the url to the configured image resource of the club (if any)</p><h3 class="">Managing Live streams</h3><p class="paragraph">Interactions with the retrieval and update of the livestreams are handled by the LiveStreamContainer and the LiveStreamRefresher.</p><h4 class="">Getting The LiveStreams</h4><p class="paragraph">The SDK internally updates the states of the livestreams and therefore it is normally sufficient to request the streams from the LiveStreamContainer via the call to &quot;getAll()&quot; These internal update can only occur if an active internet connection is existing, therefore if the internet connection was lost or the app was in the background for a longer period it makes sense to refresh the live streams with the help of the LiveStreamRefresher</p><h4 class="">Stream Changes</h4><p class="paragraph">To be informed about stream changes, this includes adding/updating and removing streams you first need to create a class that conforms to the interface of the LiveStreamContainer.Observer</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    interface Observer {<br>        /**<br>         * Called when a new live stream was added.<br>         * This is the case when a new streamer for you club started a stream<br>         *<br>         * @param liveStream - the new live stream<br>         */<br>        void onLiveStreamAdded(LiveStream liveStream);<br><br>        /**<br>         * Called when a live stream is updated.<br>         * This could be, because the streamer changed some settings,<br>         * the listener count changed ...<br>         *<br>         * @param liveStream - the stream that changed<br>         */<br>        void onLiveStreamUpdated(LiveStream liveStream);<br><br>        /**<br>         * A stream was removed, this is usually the case when a streamer went offline.<br>         *<br>         * @param liveStream - the stream that went offline<br>         */<br>        void onLiveStreamRemoved(LiveStream liveStream);<br><br>        /**<br>         * Called when more than a single stream changed.<br>         * This is normally the case when a refresh was successfully finished<br>         */<br>        void onLiveStreamListChanged();<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">The next step is to register your class with the LiveStreamContainer</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    Mycrocast.getLiveStreamContainer().addObserver(this);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Afterwards your class is receiving updates for each stream change. This can be for example because the streamer updated the description, scoring changed, the number of listeners changed, a new stream was added, a stream was removed ...</p><h3 class="">3. Playing audio of a livestream</h3><p class="paragraph">This document describes everything related to controlling the play of a LiveStream, as well as receiving any updates related to the play of a LiveStream.</p><h2 class="">Relevant classes</h2><ul><li><p class="paragraph">Control the play of a specific Livestream (including delay, spots to play etc.): <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener/-live-stream-listener/index.html">LiveStreamListener</a></p></li><li><p class="paragraph">Creation of a LivestreamListener for a specific Livestream: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener/-live-stream-listener-factory/index.html">LiveStreamListenerFactory</a></p></li><li><p class="paragraph">Holds the currently active play state: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener.state/-live-stream-listener-state/index.html">LiveStreamListenerState</a></p></li><li><p class="paragraph">Represents the play state: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener.state/-play-state/index.html">PlayState</a></p></li></ul><h2 class="">Concepts</h2><h3 class="">Playing, Pausing, Resuming, Stopping a LiveStream</h3><p class="paragraph">Starting, pausing, resuming and stopping of a LiveStream can be done via the LiveStreamListener:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public interface LiveStreamListener {  <br>  <br>	//...<br>  <br>	/**  <br>	* Start the play of the stream <br>	*/ <br>	void play();  <br><br>	/**  <br>	* Pause the live audio. Resuming will jump to the live state and not<br>	* continue where you paused the stream <br>	*/<br>	void pause();  <br><br>	/**  <br>	* Resume the stream, same behaviour like play <br>	*/<br>	void resume();  <br><br>	/**  <br>	* Stop the audio stream <br>	*/ <br>	void stop();<br><br>	/**  <br>	* Set's the delay for a livestream.<br>	* <br>	* @param seconds Time (in seconds) the playback of the livestream should be delayed.  <br>	*/<br>	void setDelay(int seconds);<br><br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">To create aLiveStreamListener you need to use the LiveStreamListenerFactory. The create-process can fail (only if the sdk could not find the LiveStream internally) and the method will then return an empty optional:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public interface LiveStreamListenerFactory {  <br>  <br>	/**  <br>	 * Creates a new instance to prepare the play of the livestream. <br>	 * Will lead to a bufferDuration of 0. <br>	 * <br>	 * @param liveStream - the livestream to play  <br>	 * @param observer   - observable to pass in to receive updates  <br>	 */Optional&lt;LiveStreamListener&gt; create(LiveStream liveStream, LiveStreamListener.Observer observer);  <br>	  <br>	/**  <br>	 * Creates a new instance to prepare the play of the livestream<br>	 * <br>	 * @param liveStream     - the livestream to play  <br>	 * @param bufferDuration - the duration of the audio buffer in milliseconds  <br>	 * @param observer       - observable to pass in to receive updates  <br>	 */Optional&lt;LiveStreamListener&gt; create(LiveStream liveStream, long bufferDuration, LiveStreamListener.Observer observer);<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Only if a LiveStream is currently playing, you will receive any updates corresponding to the audio data via the LiveStreamListener.Observer:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public interface LiveStreamListener {  <br>  <br>	/**  <br>	* Implement this interface to receive information when new <br>	* advertisements to play are available <br>	*/ <br>	interface Observer extends LiveStreamPlayer.Observer {<br>	<br>		/**  <br>		 * Received a package of audio data <br>		 * <br>		 * @param pcmData - the data received  <br>		 * @param amountToRead - the amount  <br>		 */<br>		void onAudioDataReceived(short[] pcmData, int amountToRead);  <br><br>		/**  <br>		 * State of buffering changed. <br>		 * <br>		 * @param isBuffering Whether the sdk is currently buffering audio data<br>		 * or not.  <br>		 */<br>		 void onIsBufferingChanged(boolean isBuffering);  <br>		  <br>		/**  <br>		 * Maximum delay for the livestream changed.<br>		 * <br>		 * @param milliseconds The time (in milliseconds) the livestream can be<br>		 * delayed at max.  <br>		 */<br>		 void onDelayChanged(long milliseconds);<br><br>		/**  <br>		 * Audio connection was established successfully <br>		 */<br>		void onAudioConnectionEstablished();  <br><br>		/**  <br>		 * Connection could not be established. <br>		 * This could be because you have no internet or the stream is just not online <br>		 */<br>		void onAudioConnectionFailed();  <br>		<br>		//...<br>	}<br><br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">It is recommended to play the audio data in a foreground service, so that Android does not kill the play-process if your application moves to the background (of Android).</p><p class="paragraph">For an example you can look into the LiveStreamListenerService of the example Application.</p><p class="paragraph">To determine if a LiveStream is currently playing or if a specific LiveStream is the same one as the currently playing one, you can use the LiveStreamListenerState. It will store the current state of the currently playing (or paused) LiveStream, if one is currently playing (or paused):</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public interface LiveStreamListenerState extends Observable&lt;LiveStreamListenerState.Observer&gt; {  <br><br>	//...<br><br>	/**  <br>	* @return true if we have currently a live stream in any play state that is not stopped  <br>	*/<br>	boolean hasCurrentLiveStream();  <br><br>	/**  <br>	* @param liveStream - the live stream we want to check  <br>	* @return true if this stream is our current live stream, false otherwise  <br>	*/<br>	boolean isCurrentLiveStream(final LiveStream liveStream);  <br><br>	/**  <br>	* @param liveStream - the live stream to check  <br>	* @return true if the livestream is our current stream and the stream is in paused state  <br>	*/<br>	boolean isCurrentPausedLiveStream(final LiveStream liveStream);  <br><br>	/**  <br>	* @param liveStream the live stream to check  <br>	* @return true if the livestream is our current stream and the stream is in playing state  <br>	*/<br>	boolean isCurrentPlayingLiveStream(final LiveStream liveStream);  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">If you want to receive any updates corresponding to a PlayState of any LiveStream, to update a view for example, you can add a LiveStreamListenerState.Observer to the LiveStreamListenerState:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public interface LiveStreamListenerState extends Observable&lt;LiveStreamListenerState.Observer&gt; {  <br>	/**  <br>	* Implement this interface to receive updates for the livestreams play state <br>	*/<br>	interface Observer {  <br>		/**  <br>		* Receive a play state update for a live stream * * @param liveStream - the live stream that this update is belonging too  <br>		* @param playState - the new play state  <br>		*/<br>		void onPlayStateChanged(final LiveStream liveStream, final PlayState playState);  <br>	}  <br>	<br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Calling start, pause, resume or stop on a LiveStreamListener will automatically update the state in the LiveStreamListenerState, it will also notify each LiveStreamListenerState.Observe that is currently added to the LiveStreamListenerState.</p><h3 class="">Mute music</h3><p class="paragraph">A streamer could be muted during your connection time or mute himself anytime within the current broadcast.</p><p class="paragraph">When a streamer is muted you should play the mute music, the remote URL to that file is contained in the LiveStream object.</p><p class="paragraph">After connecting check the muted flag in the LiveStream and afterwards react to the specific callbacks to changes in the mute state of the streamer.</p><h3 class="">Advertisement within the stream</h3><p class="paragraph">The streamer can at anytime decide that advertisements should be played within the broadcast.</p><p class="paragraph">If you decide to actually play the advertisement, reduce the audio of the stream, or the mute music to zero during the play and increase them afterwards again.</p><h3 class="">Pause/Resume</h3><p class="paragraph">We do not provide the functionality to actually pause a stream and later on resume at that point in time. Internally each resume/play just starts from the current live moment. If you want to provide that functionality you can implement it. You should never call pause/stop on our SDK but just reduce the volume to zero and keep storing the audio packages.</p><h3 class="">Buffering</h3><p class="paragraph">During the connection to a live stream you can configure the buffering amount. That is the amount of data to collect before providing the first audio packages. A short buffer is useful for a better user experience and to mask connectivity issues. The higher the buffer, the higher the delay and initial wait time. A value between 1s - 5s is recommended.</p><p class="paragraph">How does it work? We initially start collecting audio packages until we have collected enough to satisfy the configured buffer time. (We start in the buffering state) Afterwards we change to the playing state and start providing audio packages for playback. When changing from buffering to playing up to 10 packages are provided as burst.</p><p class="paragraph">When the buffer is empty again (bad network for example), we start buffering again until we reached the configured value.</p><h3 class="">Delay</h3><p class="paragraph">You can now configure a delay so that the user can sync the audio with any (external!) potential video source. The general flow of the delay is as following:</p><ol><li><p class="paragraph">You configure the maximum delay that is internally stored (how much audio we internally store) during initialization. 5 minutes is a good value</p></li><li><p class="paragraph">As soon as the stream is connected, we collect the audio packages and update you how much we currently have collected.</p></li><li><p class="paragraph">If enough is collected, the user can configure a delay up to the initially configured maximum</p></li><li><p class="paragraph">Any event that occurs is also processed delayed (playing of advertisement, changing the mute state and so on)</p></li><li><p class="paragraph">If the user moves the delay and &quot;jumps&quot; over an event, the event is executed (when moving to the live moment) or undone (when moving in the past)</p></li></ol><p class="paragraph">When the user pauses/stops the stream and resumes, collection of audio needs to start again.</p><h3 class="">4. Chat and ChatMessages</h3><p class="paragraph">This document describes everything you need to know to get started with the Chat in the mycrocast android sdk.</p><p class="paragraph">Check the example app to see the usage if the chat in action.</p><h2 class="">Relevant classes</h2><ul><li><p class="paragraph">Entry class for anything related to chat: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat/-chat/index.html">Chat</a></p></li><li><p class="paragraph">Represents a single chat message: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat.data/-chat-message/index.html">ChatMessage</a></p></li><li><p class="paragraph">Represents the state of the chat room: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat.data/-chat-room-status/index.html">ChatRoomStatus</a></p></li><li><p class="paragraph">Represents who send a chat message: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat.data/-chat-message-sender/index.html">ChatMessageSender</a></p></li><li><p class="paragraph">Reasons for a report of a chat message: <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.utility/-report-reason/index.html">ReportReason</a></p></li></ul><h2 class="">Concepts</h2><p class="paragraph">Every interaction with the chat is handled through the Mycrocast.Chat interface implementation.</p><h3 class="">Receiving chat messages</h3><p class="paragraph">The first step you should do is create a class that implements the Chat.Observer interface to be able to receive updates for the chat rooms.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    interface Observer {<br>        /**<br>         * A new chat message was send by somebody<br>         *<br>         * @param message - the new message<br>         */<br>        void onChatMessage(MycrocastChatMessage message);<br><br>        /**<br>         * An update for the chatroom belonging to the streamId has happened.<br>         * This indicates a status change, the streamer could have enabled or disabled the chat<br>         *<br>         * @param streamId - the if of the stream to which this change belongs<br>         * @param status   - the new status of the chat room<br>         */<br>        void onChatRoomChanged(long streamId, ChatRoomStatus status);<br><br>        /**<br>         * Function called after successfully joined a chat room.<br>         *<br>         * @param streamId - the id of the stream you joined<br>         * @param status   - the current status of the chatroom<br>         * @param messages - the chat messages already present in the chat<br>         */<br>        void onChatRoomJoined(long streamId, ChatRoomStatus status, List&lt;MycrocastChatMessage&gt; messages);<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">The next step is to register this class as an observer for the chat</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">  Mycrocast.getChat().addObserver(this);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">You are now set to receive updates for the chat</p><h3 class="">Joining a chat room</h3><p class="paragraph">Before you can interact with a specific chat room you first need to join the chat room. Before joining there is no information available if the chat is actually enabled by the streamer and if chat messages are present.</p><p class="paragraph">After joining the chat room onChatRoomJoined of the observer is called, you can now participate in the chat (if it is enabled). Additionally you now receive updates for this chat room as long as you stay joined (not calling leaveChatRoom). Updates include new chat message and changes made from the streamer to the current state of the chatroom.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * Join the chat if a chat is present for the provided stream<br>     * Implement the Observer interface to receive the OnChatRoomJoined callback as soon as the<br>     * chat was joined.<br>     * Only after joining a chat the status can be retrieved and updates for the chatroom are received<br>     *<br>     * @param streamId true if the streamId belongs to an existing stream otherwise false<br>     */<br>    boolean joinChatRoom(long streamId);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">Leaving a chat room</h3><p class="paragraph">To leave a chatroom just call leaveChatRoom with the id of the stream that chat belongs to. Afterwards you will not receive any more updates in the observer for that chat room.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * Leave a chatroom, which results in no further updates for the current chat room<br>     *<br>     * @param streamId - the stream id of the stream from where to leave the chat<br>     */<br>    void leaveChatRoom(long streamId);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">Send a message</h3><p class="paragraph">To send a chat message just call sendChatMessage with the id of the stream that chat belongs to and the actual message you want to send.</p><p class="paragraph">The message will only be send if you are joined in the chat and if the streamer did not disable the chatroom. A single message can only have 255 characters and everything larger will be cut off. You should limit the number of characters your user can enter.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * Send a chat message with the provided content to the chatroom of the provided id<br>     * The message can be at maximum 255 characters. Larger messages are cut off<br>     * The message is only send if the chatroom is active and the chat room is currently joined<br>     *<br>     * @param streamId - the id of the stream<br>     * @param message  - the message to send<br>     * @return true if the chatroom is active and joined, false otherwise<br>     */<br>    boolean sendChatMessage(long streamId, String message);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">Reporting a chat message</h3><p class="paragraph">You can provide your users with the functionality to report a chat message. Just call reportChatMessage with the message you want to report, a report reason and any additional information you want to provide. The more information we receive the better we can decide what our next steps are regarding that message.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * Send a report of a chat message to our system.<br>     * This does not automatically removes a chatter from the chat<br>     *<br>     * @param chatMessage           - the chat message that lead to the report<br>     * @param reportReason          - the reason of the reporter as what is wrong with the message<br>     * @param additionalInformation - any additional information the reporter wants to provide<br>     */<br>    void reportChatMessage(MycrocastChatMessage chatMessage, ReportReason reportReason, String additionalInformation);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">5. ErrorTypes and receiving of Errors of the SDK</h3><p class="paragraph">The sdk provides a number of errors that are all presented in the <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.error/-mycrocast-error/index.html">MycrocastError</a> class.</p><p class="paragraph">The class consist of an enum value of type <a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.error/-error-type/index.html">ErrorType</a> and a description providing more information.</p><p class="paragraph">The error types are described below as taken directly from the implementation.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public enum ErrorType {<br>    // error during the initialisation with the customer token<br>    // check if you entered it correctly<br>    AUTHENTICATION,<br>	<br>    // error with a stream interaction. This normally means that either the stream<br>    // with the id could not not be found, or that the stream was removed beforehand (the streamer<br>    // could went offline) This is more for information only as the user cannot do anything about it<br>    STREAM,<br>	<br>    // security problem because of not authorised to do something<br>    // this should only occur if you try to do something without first initialising the sdk<br>    // or your provided api key is not valid<br>    SECURITY,<br>	<br>    // the server response was unexpected<br>    // normally a status code between 4xx..5xx this indicates unusual behaviour and should<br>    // result in informing the user and maybe try later again<br>    // the description of the mycrocast error contains the status code and more information if available<br>    SERVER,<br>	<br>    // a generic exception internally occurred, for example trying to communicate while no internet<br>    // connection is available<br>    // the description of the mycrocast error contains the message of the throwable<br>    GENERIC,<br>	<br>    // for internal use only<br>    NO_CONTENT<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">Receiving Errors</h2><p class="paragraph">You have the possibility to get informed, if an error occurred in the SDK. Therefore you need to implement the ErrorReceiving.Observer:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br>* Interface that will be informed, if an error occurs somewhere in the sdk.<br>*/<br>public interface ErrorReceiving extends Observable&lt;ErrorReceiving.Observer&gt; {  <br>  <br>	/**  <br>	* The interface to be implemented to register as observer. <br>	* Here you will receive any potential error message <br>	*/ <br>	interface Observer {  <br><br>		/**  <br>		* A new error was received from the sdk <br>		* @param error - the error that was send from the sdk  <br>		*/<br>		void onError(MycrocastError error);  <br>	}<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">And add this observer to the ErrorReceiver of our SDK via:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    // add observer for receiving any error occurring in the sdk  <br>    Mycrocast.getErrorReceiving().addObserver(this);</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h1 class="">3. Android Example Application</h1><p class="paragraph">The example project implements a simple app demonstrating the different aspects of the mycrocast sdk. This should only be used as a starting point to see how to use it and enhance on it, especially in the visual elements as you see fit.</p><h2 class="">LiveStreamListActivity</h2><p class="paragraph">The LiveStreamListActivity is the first activity of the app and is responsible to show an overview of all currently available LiveStreams for your club.</p><p class="paragraph">This is visually accomplished by using a recyclerview with the usage of the LiveStreamAdapter and LiveStreamViewholder classes.</p><p class="paragraph">This activity demonstrates:</p><ul><li><p class="paragraph">usage of the LiveStreamContainer and the LiveStreamContainer.Observer</p></li><li><p class="paragraph">usage of the LiveStreamRefresher and the LiveStreamRefresher.Observer</p></li><li><p class="paragraph">usage of the LiveStreamListenerState and the LiveStreamListenerState.Observer</p></li></ul><h3 class="">LiveStreamContainer.Observer</h3><p class="paragraph">All currently available LiveStreams are stored in the LiveStreamContainer.</p><p class="paragraph">As this list of all available LiveStreams can change (as well as a single LiveStream of this list) we have the opportunity to observe the LiveStreamContainer for the following changes:</p><ul><li><p class="paragraph">the addition of a LiveStream to the container</p></li><li><p class="paragraph">the update of a LiveStream, that was already present in the container</p></li><li><p class="paragraph">the end a LiveStream, that was already in the container (by the streamer or the mycrocast backend-server)</p></li><li><p class="paragraph">multiple changes in the container (will also be invoked, if the refreshing via the LiveStreamRefresher was a success)</p></li></ul><p class="paragraph">Below the implementation of the LiveStreamContainer.Observer interface, which updates the adapter of the list and afterwards forces and visual update.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**<br>     * A new stream was received, this was because a new streamer of you club started streaming<br>     * We add it to the adapter and force an update of the recycler view<br>     *<br>     * @param liveStream - the new live stream<br>     */<br>    @Override<br>    public void onLiveStreamAdded(LiveStream liveStream) {<br>        this.adapter.add(liveStream);<br>        this.runOnUiThread(() -&gt; this.adapter.notifyDataSetChanged());<br>    }<br><br>    /**<br>     * We received an update for a specific stream. This could be for example because the<br>     * number of listener changed.<br>     * We force an update for the recycler view<br>     *<br>     * @param liveStream - the stream that changed<br>     */<br>    @Override<br>    public void onLiveStreamUpdated(LiveStream liveStream) {<br>        this.adapter.update(liveStream);<br>        this.runOnUiThread(() -&gt; this.adapter.notifyDataSetChanged());<br>    }<br><br>    /**<br>     * A stream went offline, this could be because a streamer ended his stream<br>     * We need to remove it visually and therefore force an update of the recycler view<br>     *<br>     * @param liveStream - the stream that went offline<br>     */<br>    @Override<br>    public void onLiveStreamRemoved(LiveStream liveStream) {<br>        this.adapter.remove(liveStream);<br>        this.runOnUiThread(() -&gt; this.adapter.notifyDataSetChanged());<br>    }<br><br>  /**<br>     * multiple entries have changed, therefore we update everything<br>     */<br>    @Override<br>    public void onLiveStreamListChanged() {<br>        this.adapter.setAll(Mycrocast.getLiveStreamContainer().getAll());<br>        this.runOnUiThread(() -&gt; this.adapter.notifyDataSetChanged());<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">LiveStreamRefresher.Observer</h3><p class="paragraph">For manually refreshing (via reload from the backend-server) the list of available LiveStreams we need to use the LiveStreamRefresher. Only one refresh can be active at the same time. (So if a refresh is currently in progress, you can't demand a refresh again.)</p><p class="paragraph">To get informed if a refresh was finished (either successfully or not), you need to add a LiveStreamRefresher.Observer to the LiveStreamRefresher.</p><p class="paragraph">Below the Implementation of the LiveStreamRefresher.Observer interface to receive the callback when the refresh is done. As the internal list of all currently available LiveStreams changes, you automatically you will be notified via the LiveStreamContainer.Observer.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * Refreshing the streams from the server has finished<br>     */<br>    @Override<br>    public void OnRefreshFinished() {<br>        this.runOnUiThread(() -&gt; this.refreshLayout.setRefreshing(false));<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">LiveStreamListenerState.Observer</h3><p class="paragraph">The LiveStreamListenerState stores the state of the currently playing LiveStream, if any is currently playing/paused.</p><p class="paragraph">To get informed if a PlayState of a LiveStream changes we can implement and the LiveStreamListenerState.Observer to the LiveStreamListenerState.</p><p class="paragraph">Below the implementation of the LiveStreamListenerState.Observer to react to the PlayState-Changes, redrawing the list of the LiveStreams to update the image of the PlayButton.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    @Override<br>    public void onPlayStateChanged(LiveStream liveStream, PlayState playState) {<br>        this.runOnUiThread(() -&gt; this.adapter.notifyDataSetChanged());<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">OnResume</h3><p class="paragraph">Lifecycle function of the activity. Here we get the all currently active LiveStreams, register to our observer-interfaces to receive the updates and refresh the current view.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">	@Override<br>protected void onResume() {<br>    super.onResume();<br><br>    // we could have missed some updates in the list of currently active livestreams,  <br>    // so we get all currently active livestreams and update our adapter accordingly <br>    this.adapter.setAll(this.liveStreamContainer.getAll());<br>    this.adapter.notifyDataSetChanged();<br><br>    // register the observers again, so we get any updates  <br>    this.liveStreamListenerState.addObserver(this);<br>    this.liveStreamContainer.addObserver(this);<br>    this.liveStreamRefresher.addObserver(this);<br><br>    // if a refresh of our list of currently active livestream is in progress,  <br>    // we want to show this progress via our refreshLayout <br>    boolean isRefreshInProgress = this.liveStreamRefresher.isRefreshInProgress();<br>    this.refreshLayout.setRefreshing(isRefreshInProgress);<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">OnPause</h3><p class="paragraph">Unregister from the observer as the view is no longer visible and therefore we are not interested to keep it updated.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">	@Override<br>    protected void onPause() {<br>        super.onPause();<br>    <br>        // clean up and remove observer, so we don't get any updates while this view is not in the foreground  <br>        this.liveStreamListenerState.removeObserver(this);<br>        this.liveStreamContainer.removeObserver(this);<br>        this.liveStreamRefresher.removeObserver(this);<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">LiveStreamDetailActivity</h2><p class="paragraph">This activity can be reached by selecting a live stream cell from the LiveStreamListActivity.</p><p class="paragraph">This represents the details view of the selected stream.</p><p class="paragraph">This view shows the following concepts:</p><ul><li><p class="paragraph">Rating, you can rate the stream by hitting either the like or dislike</p></li><li><p class="paragraph">Listening to the stream - you can toggle the play state though the provided play button</p></li><li><p class="paragraph">Stream Details - either showing a general stream view or Scoring depending on what the streamer had configured</p></li><li><p class="paragraph">Chat Navigation - You can move from here to the chat of the specific stream</p></li></ul><h3 class="">Rating</h3><p class="paragraph">Rating is done via the LiveStreamRater</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public interface LiveStreamRater extends Observable&lt;LiveStreamRater.Observer&gt; {<br><br>    interface Observer {<br>        /**<br>         * Get informed about changes of the rating from the user. This is called after a user changed the<br>         * Rating<br>         * @param liveStream - the stream for which the rating changed<br>         * @param oldRating - the old rating<br>         * @param newRating - the new and current rating<br>         */<br>        void onRatingChanged(@NonNull LiveStream liveStream, LiveStreamRating oldRating, LiveStreamRating newRating);<br>    }<br><br>    /**<br>     * Like a certain stream. If current stream was already liked by the user, reset the rating to neutral<br>     * @param liveStream - the stream to like<br>     */<br>    void Like(@Nullable LiveStream liveStream);<br><br>    /**<br>     * Dislike a certain stream. If the current stream rating was already dislike the rating is reset to neutral<br>     * @param liveStream - the stream to dislike<br>     */<br>    void Dislike(@Nullable LiveStream liveStream);<br><br>    /**<br>     * Request the users current rating for the provided live stream<br>     * @param liveStream - the live stream in question<br>     * @return the rating of the current user for this stream<br>     */<br>    LiveStreamRating getCurrentRating(@Nullable LiveStream liveStream);<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">To react to changes for the rating you can subscribe yourself to the onRatingChanged Observer</p><h3 class="">Listening to the stream / toggling the play state</h3><div class="sample-container"><pre><code class="block lang-java" theme="idea">    private void onPlayButtonClicked() {<br>        if (this.liveStreamListenerState.isCurrentLiveStream(this.liveStream)) {<br>            if (this.liveStreamListenerState.isCurrentPlayingLiveStream(this.liveStream)) {<br>                this.sendBroadcast(new Intent(BroadcastIntent.PAUSE_LIVE_STREAM));<br>                return;<br>            }<br><br>            this.sendBroadcast(new Intent(BroadcastIntent.RESUME_LIVE_STREAM));<br>            return;<br>        }<br><br>        if (this.liveStreamListenerState.hasCurrentLiveStream()) {<br>            this.sendBroadcast(new Intent(BroadcastIntent.STOP_LIVE_STREAM));<br>        }<br><br>        Intent startIntent = LiveStreamListenerService.NewInstance(this, this.liveStream);<br>        this.startService(startIntent);<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Hitting the play button if nothing is running, we instantiate a new Instance of LiveStreamListenerService, our custom implementation of a foreground service responsible for playing the audio and controlling the play state in general as well as playing advertisements.</p><h3 class="">Stream Details</h3><p class="paragraph">A stream has either only a title and a description or an additional scoring field with the 2 competing teams as well as the scoring for each of those teams.</p><p class="paragraph">We just check the hasScoring function of the LiveStream to determine what to show</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">        /**<br>     * If this stream is of type scoring (hasScoring is true) we update the scoring visuals<br>     * Otherwise we just hide them<br>     */<br>    private void updateScoringViews() {<br>        if (this.liveStream.hasScoring()) {<br>            this.scoringCardView.setVisibility(View.VISIBLE);<br><br>            Team home = this.liveStream.getScoring().getHomeTeam();<br>            this.homeTeamScoreView.setText(String.valueOf(home.getScore()));<br>            this.homeTeamNameView.setText(home.getName());<br><br>            Team guest = this.liveStream.getScoring().getGuestTeam();<br>            this.guestTeamScoreView.setText(String.valueOf(guest.getScore()));<br>            this.guestTeamNameView.setText(guest.getName());<br>        } else {<br>            this.scoringCardView.setVisibility(View.GONE);<br>        }<br>    }<br>    <br>    /**<br>     * Update the view of listener count, genre and language<br>     */<br>    private void updateDetailViews() {<br>        this.listenerCountView.setText(String.valueOf(this.liveStream.getListenerCount()));<br>        this.genreView.setText(this.liveStream.getGenre().toString());<br>        this.languageView.setText(this.liveStream.getLanguage().getNativeLanguage());<br>    }<br><br>    /**<br>     * Update the general fields of each stream<br>     */<br>    private void updateDescriptionViews() {<br>        this.titleView.setText(this.liveStream.getTitle());<br>        this.descriptionView.setText(this.liveStream.getDescription());<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">Chat</h3><p class="paragraph">To open the chat we just navigate to the ListenerChatActivity on click</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    this.chatCardView.setOnClickListener(v -&gt; <br>	{<br>		this.startActivity(ListenerChatActivity.newInstance(this, this.liveStream));<br>	});</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">ListenerChatActivity</h2><p class="paragraph">This activity is the implementation of an example chat with the mycrocast sdk.</p><p class="paragraph">The chat is visually represented by a recyclerview with the ChatViewHolder as the visual implementation for a single chat message.</p><p class="paragraph">On the bottom of the chat view you have an input element and a send button so that the user can participate in the chat.</p><p class="paragraph">Should the chat be disabled or is already disabled, the visual elements are hidden and an information is presented to the user.</p><h2 class="">Workflow</h2><p class="paragraph">The next section describes the workflows for the mycrocast sdk but leaves out any irrelevant parts (like the configuration of the recyclerview)</p><h4 class="">OnResume</h4><p class="paragraph">When the view/activity is opened, we do the following</p><ol><li><p class="paragraph">Check if the livestream this view belongs to was removed in the meantime as the app was for example in the background</p></li><li><p class="paragraph">Register ourselves for chat update to the class as the class conforms to the Chat.Observer interface</p></li><li><p class="paragraph">Register ourselves for stream updates as the class also conforms to LiveStreamContainer.Observer -> we want to leave the view in case our current stream stops</p></li><li><p class="paragraph">Check if we previously joined the chat, if so we get the internal messages again and display them, otherwise join the chat</p></li></ol><div class="sample-container"><pre><code class="block lang-java" theme="idea">        @Override<br>        protected void onResume() {<br>           super.onResume();<br>   <br>           // first check if the stream was not removed during the time<br>           // the observers where not active (streamer could have stopped in the meantime<br>           Optional&lt;LiveStream&gt; optional = this.findLiveStream(this.liveStreamContainer);<br>           if (optional.isEmpty()) {<br>               this.finish();<br>               return;<br>           }<br>   <br>           // if we are not currently in the chat, we join<br>           if (this.chat.chatJoined(this.liveStream.getId())) {<br>               ChatRoomStatus status = this.chat.getChatRoomStatus(this.liveStream.getId());<br>               this.chatRoomStatusChange(status);<br>   <br>           } else {<br>               // we joined previously therefore we just update the view<br>               // with potential missed messages or chatroom state updates<br>               this.chat.joinChatRoom(this.liveStream.getId());<br>               Optional&lt;List&lt;MycrocastChatMessage&gt;&gt; messages = this.chat.getCurrentMessage(this.liveStream.getId());<br>               if (messages.isPresent()) {<br>                   this.chatMessageAdapter.setChatMessages(messages.get());<br>                   this.chatMessageAdapter.notifyDataSetChanged();<br>               }<br>           }<br>		   <br>		   // register observers again<br>           this.chat.addObserver(this);<br>           this.liveStreamContainer.addObserver(this);<br>       }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">OnPause</h4><p class="paragraph">OnPause we unregister again for the above</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">       @Override<br>       protected void onPause() {<br>           super.onPause();<br>   <br>           // clean up observers, we do not get updates in this view anymore<br>           this.chat.removeObserver(this);<br>           this.liveStreamContainer.removeObserver(this);<br>       }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">OnChatRoomJoined</h4><p class="paragraph">Required function from the Chat.Observer interface. This function is called when we successfully joined a chatroom</p><p class="paragraph">We just check the chat status get the messages and update the corresponding views accordingly</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**<br> * We received a callback on the process of joining a chatroom<br> * First we need to check if this callback is for our current chatroom<br> * Afterwards we can process the received chat messages and chat room status<br> * @param streamId - the id of the stream you joined<br> * @param status   - the current status of the chatroom<br> * @param messages - the chat messages already present in the chat<br> */<br>@Override<br>public void onChatRoomJoined(long streamId, ChatRoomStatus status, List&lt;MycrocastChatMessage&gt; messages) {<br>    if (this.liveStream.getId() == streamId) {<br>        this.runOnUiThread(() -&gt; {<br>            this.chatRoomStatusChange(status);<br>            this.chatMessageAdapter.setChatMessages(messages);<br>            this.chatMessageAdapter.notifyDataSetChanged();<br>        });<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">OnChatMessage</h4><p class="paragraph">This is a function that is required to be implemented to conform to the Chat.Observer interface.</p><p class="paragraph">Here we receive a new chat message and just update the view.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">       /**<br>        * We received a new chat message, this very naive implementation<br>        * just provides the adapter with the fresh list and lets redraw everything in case<br>        * the chat message belongs to our current live stream<br>        * @param message - the new message<br>        */<br>       @Override<br>       public void onChatMessage(MycrocastChatMessage message) {<br>           if (message.getStreamId() == this.liveStream.getId()) {<br>               Optional&lt;List&lt;MycrocastChatMessage&gt;&gt; messages = this.chat.getCurrentMessage(this.liveStream.getId());<br>               if (messages.isPresent()) {<br>                   this.runOnUiThread(() -&gt; {<br>                       this.chatMessageAdapter.setChatMessages(messages.get());<br>                       this.chatMessageAdapter.notifyDataSetChanged();<br>                   });<br>               }<br>           }<br>       }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">OnChatRoomChanged</h4><p class="paragraph">Required function to implement to follow the Chat.Observer interface, here we receive updates to the chat status, the chat was either enabled or disabled</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">      /**<br>        * We received an update for a chatroom, first we need to decide if it is belonging to our<br>        * current chat afterwards we update the view<br>        * @param streamId - the if of the stream to which this change belongs<br>        * @param status   - the new status of the chat room<br>        */<br>       @Override<br>       public void onChatRoomChanged(long streamId, ChatRoomStatus status) {<br>           if (this.liveStream.getId() == streamId) {<br>               this.runOnUiThread(() -&gt; {<br>                   this.chatRoomStatusChange(status);<br>               });<br>           }<br>       }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">onChatMessageSendClicked</h4><p class="paragraph">Function that is executed when the send button was hit. This will send a new chat message to the chat if the input was not empty</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">       /**<br>        * We hit the send button to send a new message<br>        * This is only possible when actually something is written<br>        */<br>       private void onChatMessageSendClicked() {<br>           String message = this.messageInput.getText().toString();<br>           if (message == null || message.isEmpty()) {<br>               return;<br>           }<br>   <br>           this.chat.sendChatMessage(this.liveStream.getId(), message);<br>           this.messageInput.setText(&quot;&quot;);<br>           this.messageInput.setFocusable(false);<br>           this.messageInput.setFocusable(true);<br>       }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">AdvertisementPlayActivity</h2><p class="paragraph">This activity is opened when we decide we want to play an advertisement after we received an event that new advertisements are available.</p><p class="paragraph">This class does:</p><ul><li><p class="paragraph">Start playing the audio spot</p></li><li><p class="paragraph">Shows the information about the advertisement</p></li><li><p class="paragraph">Determine if a banner is configured and shows it if present</p></li><li><p class="paragraph">Closes itself as soon as the audio spot is over</p></li></ul><p class="paragraph">The information for the advertisement are passed in the extras bundle of the intent</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * Create a new instance of this activity as intent to be opened and<br>     * pass the specific information of the provided ad as extras in the bundle<br>     * @param context - context required to create the intent<br>     * @param advertisementPlay - the advertisement we want to display<br>     * @return the intent that can be used to start this activity<br>     */<br>    public static Intent newInstance(Context context, SpotPlay advertisementPlay) {<br>        Intent result = new Intent(context, AdvertisementPlayActivity.class);<br>        result.putExtra(AUDIO_URL_KEY, advertisementPlay.getAudioUrl());<br>        result.putExtra(DURATION_KEY, advertisementPlay.getDuration());<br><br>        AdvertisementBanner banner = advertisementPlay.getBanner();<br>        boolean hasBanner = banner != null;<br>        result.putExtra(HAS_BANNER_KEY, hasBanner);<br>        if (hasBanner) {<br>            result.putExtra(BANNER_IMAGE_URL, banner.getImageUrl());<br>            result.putExtra(BANNER_TARGET_URL, banner.getTargetUrl());<br>            result.putExtra(BANNER_DESCRIPTION, banner.getDescription());<br>        }<br><br>        return result;<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">Show the information</h3><p class="paragraph">We need to determine if a banner was configured if so we can show it. This is a square image.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    @Override<br>    protected void onCreate(@Nullable Bundle savedInstanceState) {<br>		// ...<br>		// removed parts for brevity sake!<br><br>        // if a banner was configured during the creation of the advertisement<br>        // we want to show it<br>        boolean hasBanner = intent.getBooleanExtra(HAS_BANNER_KEY, false);<br>        if (hasBanner) {<br>            this.bannerImageUrl = intent.getStringExtra(BANNER_IMAGE_URL);<br>            this.bannerTargetUrl = intent.getStringExtra(BANNER_TARGET_URL);<br>            this.bannerDescription = intent.getStringExtra(BANNER_DESCRIPTION);<br>        }<br><br>        this.descriptionView = this.findViewById(R.id.tv_advertisement_description);<br>        this.bannerImageView = this.findViewById(R.id.iv_advertisement_banner);<br>       <br>        this.currentProgressView = this.findViewById(R.id.tv_advertisement_play_progress);<br>        this.maxProgressView = this.findViewById(R.id.tv_advertisement_duration);<br>        this.progressBar = this.findViewById(R.id.pb_advertisement_play);<br><br>        this.setDataToViews();<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">Learn more</h4><p class="paragraph">When a banner is configured it is required to provide a target url, a website that should be opened in case the user wants more information. This could happen for example on click of the image, we decided to add a &quot;Learn more&quot; button that opens the url on click</p><h3 class="">Start the audio</h3><p class="paragraph">As the audio spot is just a remote mp3 file or any other playable format we just create a new Mediaplayer and play it.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">      this.mediaPlayer = MediaPlayer.create(this, Uri.parse(this.audioUrl));<br>      this.mediaPlayer.setOnCompletionListener(m -&gt; this.onAdvertisementPlayFinished());<br>      this.mediaPlayer.start();</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h4 class="">Advertisement Finished</h4><p class="paragraph">When the audio spot has ended we remove the activity again.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">    /**<br>     * We are done playing the advertisement, therefore we close the activity<br>     */<br>    private void onAdvertisementPlayFinished() {<br>        this.sendBroadcast(new Intent(BroadcastIntent.ON_ADVERTISEMENT_PLAY_FINISHED));<br>        this.finish();<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">LiveStreamListenerService</h2><p class="paragraph">This foreground service is responsible for:</p><ul><li><p class="paragraph">start, pause, resume and stop the playing of a LiveStream</p></li><li><p class="paragraph">playing the (configured) mute-music of a LiveStream, if the LiveStream is currently muted</p></li><li><p class="paragraph">starting to play an AdvertisementPlay (via starting an AdvertisementPlayActivity)</p></li><li><p class="paragraph">reacts to changes in the internet-connectivity of the example application</p></li><li><p class="paragraph">configuring audio buffer and audio delay</p></li></ul><p class="paragraph">This demonstrates following functionalities of the SDK:</p><ul><li><p class="paragraph">usage of the LiveStreamListenerFactory</p></li><li><p class="paragraph">usage of the LiveStreamListener and the LiveStreamListener.Observer</p></li><li><p class="paragraph">usage of the LiveStreamContainer and the LiveStreamContainer.Observer</p></li><li><p class="paragraph">usage of the LiveStreamListenerState and the LiveStreamListenerState.Observer</p></li></ul><p class="paragraph">It also demonstrates other functionalities, that should considered:</p><ul><li><p class="paragraph">a Notification (that is essential for a Foreground Service)</p></li><li><p class="paragraph">a BroadcastReceiver and Intents (for communication between Activities and Service)</p></li><li><p class="paragraph">a Connection observer, that will inform you if the application lost/reestablished the internet connection, e.g. via the InternetConnectionWatcher of the example app</p></li></ul><h2 class="">LiveStreamListenerFactory</h2><p class="paragraph">This factory is responsible for the creation of a LiveStreamListener for a specific LiveStream. Here it is possible to configure an amount of milliseconds for the audio buffer. This value defines the duration in which audio data are buffered before you receive it via the observer method (see below). Every time the audio buffer is empty it will always store audio data till the buffer is full.</p><p class="paragraph">If the creation was not a success (and therefore the Optional is empty), we want to stop the service right away.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public int onStartCommand(Intent intent, int flags, int startId) {  <br>	// ...<br><br>	LiveStream liveStream = optional.get();<br><br>	// try to create new LiveStreamListener  <br>	Optional&lt;LiveStreamListener&gt; optionalListener = this.listenerFactory.create(liveStream, this);  <br>	if (optionalListener.isEmpty()) {  <br>		this.stopService();  <br>		return Service.START_STICKY;  <br>	}  <br>		<br>	// ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">Configure the Audio Buffer</h2><p class="paragraph">While creating the LivestreamListener via the factory above it is also possible to configure your desired Audio Buffer duration in milliseconds:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public int onStartCommand(Intent intent, int flags, int startId) {  <br>	// ...<br><br>	final LiveStream liveStream = optional.get();<br>	final long audioBufferMS = 3000; // some specific value you want.<br><br>	// try to create new LiveStreamListener  <br>	Optional&lt;LiveStreamListener&gt; optionalListener = this.listenerFactory.create(liveStream, audioBufferMS, this);  <br>		<br>	// ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Once you configured the audio buffer duration for a LivestreamListener, you cant change it to another value. So its only configurable while the creation.</p><p class="paragraph">If you do not configure an audio buffer at all or you configure a value which is not supported (e.g. negative numbers), the buffer will be set to 0.</p><p class="paragraph">For changes of the buffering state, you will get notified by the LivestreamListener.Observer:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br> * Show the user some information about the buffering state. <br> * <br> * @param isBuffering Whether the sdk is currently buffering audio data or not.  <br> */<br>@Override  <br>public void onIsBufferingChanged(final boolean isBuffering) {<br>	// ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">Adjust the Audio Delay</h2><p class="paragraph">While configuring the Mycrocast SDK you have the possibility to configure the maximum possible audio delay (in seconds) possible for the application:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">public class MycrocastExampleApplication extends Application {<br><br>	// replace with the maximum number of seconds for the audio delay you want<br>	// to support<br>	private static final int MAX_AUDIO_DELAY = 30;<br><br>    @Override<br>    public void onCreate() {<br>        super.onCreate();<br><br>		// initialize with the sdk delay<br>		Mycrocast.initialize(API_KEY, CUSTOMER_TOKEN, PreferenceManager.getDefaultSharedPreferences(this), MAX_AUDIO_DELAY);<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Now while listening you can adjust the delay to the live audio via the delay(int seconds) method of the LivestreamListener. The default value is 0, which indicates a non existing delay. (Therefor if you want to remove the delay set the seconds to 0.)</p><p class="paragraph">After starting to listen to a livestream the Mycrocast SDK must collect audio data. And of course it is impossible to set a delay which is greater than the duration of the collected audio data. Therefore your value for the delay must be in the range from 0 to the currently maximum amount possible. This maximum amount of time possible will be given to you by the LivestreamListener.Observer. This value increases till it reaches your maximum configured amount (in your application class). After this the method of the observer will not be called again.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">private LiveStreamListener listener;<br>private long currentDelay = 0; // start value for delay<br>private long currentMaxDelay = 0; // current possible max delay<br><br>/// ...<br><br>private void adjustDelay(int delay) {  <br>    int newDelay = this.currentDelay + delay;  <br>    newDelay = Math.max(0, Math.min(newDelay, this.currentMaxDelay));  <br>  <br>    this.listener.setDelay(newDelay);  <br>    this.currentDelay = newDelay;  <br>}<br><br>private void removeDelay() {  <br>    this.listener.setDelay(0);  <br>    this.currentDelay = 0;  <br>}<br><br>/// ...<br><br>/**  <br> * Adjust the maximum delay the user can select.<br> * <br> * @param milliseconds The time (in milliseconds) the livestream can be delayed<br> * at max.  <br> */<br>@Override  <br>public void onDelayChanged(long milliseconds) {  <br>	this.currentMaxDelay = (int) (milliseconds / 1000);<br>}<br><br>/// ...</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">LiveStreamListener & LiveStreamListener.Observer</h2><p class="paragraph">The LiveStreamListener is responsible for starting, pausing, resuming and stopping the play of a LiveStream as well as storing all the AdvertisementPlays, that should be played.</p><p class="paragraph">The LiveStreamListener will automatically start playing after its successful creation.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public int onStartCommand(Intent intent, int flags, int startId) {  <br>	//...<br><br>	// start playing from the stream  <br>	this.listener = optionalListener.get();  <br>	this.listener.play();  <br><br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">The pausing, resuming as well as the stopping of the LiveStreamListener will be primarily triggered by receiving (via BroadcastReceiver) and processing Intents, that are send by the activities.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">private void pausePlay() {  <br>	this.listener.pause();  <br><br>	//...<br>}  <br>  <br>private void resumePlay() {  <br>	this.listener.resume();  <br><br>	//...<br>}  <br>  <br>private void stopPlay() {  <br>	this.stopService();  <br>}<br><br>private void stopService() {  <br>	//...  <br><br>	// ensure listener is stopped  <br>	if (this.listener != null) {  <br>		this.listener.stop();  <br>	}<br>	<br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Via the LiveStreamListener.Observer it will also notify you for new queued AdvertisementPlay:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br> * New advertisements are available, we get them and display them <br> * during the playback of the audio spot we mute the live track <br> */<br> @Override  <br>public void onAdvertisementPlayQueued() {<br>	// ...<br>}<br><br>/**  <br> * Creates and starts a new AdvertisementPlayActivity for playing and displaying the AdvertisementPlay. <br> *<br> * @param advertisementPlay to play and display in an AdvertisementPlayActivity  <br> */<br>private void startAdvertisementPlay(SpotPlay advertisementPlay) {  <br>	// ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">... as well as changes related to the audio data of the LiveStream:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br> * We received a new audio package to play, we forward it to the <br> * AudioTrack for playing <br> * <br> * @param pcmData - the data received  <br> * @param amountToRead - the amount  <br> */<br>@Override  <br>public void onAudioDataReceived(short[] pcmData, int amountToRead) {  <br>	// ...<br>}  <br><br>/**  <br> * The connection to the broadcast was successfully established. <br> */<br>@Override  <br>public void onAudioConnectionEstablished() {  <br>	// ...<br>}  <br>  <br>/**  <br> * The connection to the broadcast of the livestream could not be established (after several tries) <br> */<br>@Override  <br>public void onAudioConnectionFailed() {  <br>	// ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">LiveStreamContainer & LiveStreamContainer.Observer</h2><p class="paragraph">We need the LiveStreamContainer to find the LiveStream via the id we stored in the Bundle at the creation of the LiveStreamListenerService.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public int onStartCommand(Intent intent, int flags, int startId) {  <br>	this.liveStreamId = intent.getLongExtra(Constants.LIVE_STREAM_ID_KEY, Constants.INVALID_ID);  <br><br>	// checking if the current live stream still exists or the provided id is  <br>	// valid at all, otherwise we stop the service<br>	Optional&lt;LiveStream&gt; optional = this.liveStreamContainer.find(this.liveStreamId);  <br>	if (optional.isEmpty()) {  <br>		this.stopService();  <br>		return Service.START_STICKY;  <br>	}<br><br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">We also need to observe the LiveStreamContainer for all possible changes of our current LiveStream, especially if the LiveStream was updated or removed.</p><h3 class="">Update</h3><ul><li><p class="paragraph">we need to check if the mute-state of the LiveStream changed and start/stop the mute-music of the LiveStream accordingly</p></li><li><p class="paragraph">also if you implemented a custom Notification, that displays some information of the LiveStream, should also be updated</p></li></ul><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public void onLiveStreamUpdated(LiveStream liveStream) {  <br>	if (this.liveStreamId == liveStream.getId()) {  <br>		this.checkForMuteMusic(liveStream);  <br><br>		// here you could update your custom notification  <br>	}  <br>}<br><br>private void checkForMuteMusic(LiveStream liveStream) {  <br>	if (liveStream.isMuted() == this.isLiveStreamMuted) {  <br>		// the mute state has not changed -&gt; nothing to do  <br>		return;  <br>	}  <br><br>	// mute state has changed, either start or stop playing of the mute music  <br>	this.isLiveStreamMuted = liveStream.isMuted();  <br>	if (this.isLiveStreamMuted) {  <br>		this.startMuteMusic(liveStream.getMuteMusicUrl());  <br>		return;<br>	}  <br><br>	this.stopMuteMusic();  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class="">Remove</h3><ul><li><p class="paragraph">if our LiveStream was removed from the LiveStreamContainer, we need to stop our service and stop all currently playing media</p></li></ul><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public void onLiveStreamRemoved(LiveStream liveStream) {  <br>	if (this.liveStreamId == liveStream.getId()) {  <br>		this.stopService();  <br>	}  <br>}<br><br>@Override  <br>public void onLiveStreamListChanged() {  <br>	Optional&lt;LiveStream&gt; optional = this.liveStreamContainer.find(this.liveStreamId);  <br>	if (optional.isEmpty()) {  <br>		this.stopService();  <br>		return; <br>	}  <br>  <br>	//...  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">LiveStreamListenerState & LiveStreamListenerState.Observer</h2><p class="paragraph">We need to get informed when the PlayState of our LiveStream changes to adjust the playing of the broadcast of the LiveStream via the audio-track accordingly. For this we need to implement a LiveStreamListenerState.Observer as following:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public void onPlayStateChanged(LiveStream liveStream, PlayState playState) {  <br>	// play state updates of other LiveStreams are not interesting<br>	if (this.liveStreamId != liveStream.getId()) {  <br>		return;  <br>	}  <br><br>	switch (playState) {<br>		case PLAYING:<br>			this.audioTrack.play();<br>			break;<br>			<br>		case PAUSED:<br>			this.audioTrack.pause();<br>			break;<br>			<br>		case STOPPED:<br>			this.audioTrack.stop();<br>			break;<br>	}  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">Observing the Internet Connection</h2><p class="paragraph">It is possible that during the play of the Broadcast or Mute-Music of the LiveStream the internet connection of the running device was lost. Then we need to make sure, that the playing of the Broadcast as well as Mute-Music will be stopped.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br> * Connection to the internet was lost. <br> * We need to stop the play of the livestream or mute-music. <br> */<br>@Override  <br>public void onConnectionLost() {  <br>	this.listener.stop();  <br><br>	if (this.isLiveStreamMuted) {  <br>		this.stopMuteMusic();  <br>	}  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">It will be started accordingly again, if the internet connection was reestablished and our LiveStream is still present in our container.</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">/**  <br> * Connection to the internet was reestablished. <br> * We can start playing the livestream again. <br> */<br>@Override  <br>public void onConnectionEstablished() {  <br>	Optional&lt;LiveStream&gt; optional = this.liveStreamContainer.find(this.liveStreamId);  <br>	if (optional.isEmpty()) {  <br>		this.stopService();  <br>		return; <br>	}  <br><br>	this.listener.play();  <br><br>	LiveStream liveStream = optional.get();  <br>	this.isLiveStreamMuted = liveStream.isMuted();  <br>	if (this.isLiveStreamMuted) {  <br>		this.startMuteMusic(liveStream.getMuteMusicUrl());  <br>	} else {  <br>		this.stopMuteMusic();  <br>	}  <br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class="">Playing of the audio from the broadcast of the LiveStream</h2><p class="paragraph">For the playing of the audio data in this example application we simply use an audio track.</p><p class="paragraph">For the creation, that is shown below, some settings are mandatory for playing our decoded audio data and MUST be set accordingly, like:</p><ul><li><p class="paragraph">sample rate of 48000 Hz</p></li><li><p class="paragraph">channel out: mono (at this point: we do not support stereo)</p></li><li><p class="paragraph">encoding: PCM 16Bit</p></li><li><p class="paragraph">buffer size: 8 \* 1024 bytes</p></li></ul><p class="paragraph">Every other settings can be changed as you like and /or prefer.</p><p class="paragraph">The is the creation of the audio track for Android API 22 and lower:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">private AudioTrack createAudioTrack() {  <br>	if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {  <br>		return new AudioTrack(AudioManager.STREAM_MUSIC,  <br>							  48000,  <br>							  AudioFormat.CHANNEL_OUT_MONO,  <br>							  AudioFormat.ENCODING_PCM_16BIT,  <br>							  8 * 1024, <br>							  AudioTrack.MODE_STREAM);  <br>	}<br>	<br>	//...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">The is the creation of the audio track for Android API 23 and greater:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">private AudioTrack createAudioTrack() {<br>    //...<br><br>    AudioAttributes audioAttributes = new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA)<br>            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)<br>            .setLegacyStreamType(AudioManager.STREAM_MUSIC)<br>            .build();<br><br>    AudioFormat audioFormat = new AudioFormat.Builder().setEncoding(AudioFormat.ENCODING_PCM_16BIT)<br>            .setSampleRate(48000)<br>            .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)<br>            .build();<br><br>    return new AudioTrack.Builder().setAudioAttributes(audioAttributes)<br>            .setAudioFormat(audioFormat)<br>            .setBufferSizeInBytes(8 * 1024)<br>            .build();<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">After starting to play a LiveStream via the LiveStreamListener was a success, you will receive the decoded audio data via the implementation of the onAudioDataReceived-method from the LiveStreamListener.Observer:</p><div class="sample-container"><pre><code class="block lang-java" theme="idea">@Override  <br>public void onAudioDataReceived(short[] pcmData, int amountToRead) {  <br>	if (this.audioTrack == null) {  <br>		return;  <br>	}  <br><br>	this.audioTrack.write(pcmData, 0, amountToRead);  <br>} </code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div></div>
  </div>
  <h2 class="">Packages</h2>
  <div class="table"><a data-name="1154335861%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.chat" id="1154335861%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat/index.html">de.mycrocast.android.sdk.chat</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="1154335861%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-1591084025%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.chat.data" id="-1591084025%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.chat.data/index.html">de.mycrocast.android.sdk.chat.data</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-1591084025%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="136218108%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.core" id="136218108%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.core/index.html">de.mycrocast.android.sdk.core</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="136218108%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-412231368%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.core.util" id="-412231368%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.core.util/index.html">de.mycrocast.android.sdk.core.util</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-412231368%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="224109071%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.error" id="224109071%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.error/index.html">de.mycrocast.android.sdk.error</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="224109071%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-2089184538%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.checker.domain" id="-2089184538%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.checker.domain/index.html">de.mycrocast.android.sdk.live.checker.domain</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-2089184538%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="844524188%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.container" id="844524188%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.container/index.html">de.mycrocast.android.sdk.live.container</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="844524188%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-741921805%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.data" id="-741921805%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data/index.html">de.mycrocast.android.sdk.live.data</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-741921805%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="1533181953%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.data.description" id="1533181953%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data.description/index.html">de.mycrocast.android.sdk.live.data.description</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="1533181953%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-265227529%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.data.language" id="-265227529%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.data.language/index.html">de.mycrocast.android.sdk.live.data.language</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-265227529%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-351462147%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.listener" id="-351462147%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener/index.html">de.mycrocast.android.sdk.live.listener</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-351462147%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="659953696%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.listener.state" id="659953696%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.listener.state/index.html">de.mycrocast.android.sdk.live.listener.state</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="659953696%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-1812966742%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.player" id="-1812966742%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.player/index.html">de.mycrocast.android.sdk.live.player</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-1812966742%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="922760806%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.rating" id="922760806%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.rating/index.html">de.mycrocast.android.sdk.live.rating</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="922760806%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-1046946122%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.live.refresh" id="-1046946122%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.live.refresh/index.html">de.mycrocast.android.sdk.live.refresh</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-1046946122%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="-1999606541%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.observer" id="-1999606541%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.observer/index.html">de.mycrocast.android.sdk.observer</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-1999606541%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="53874263%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.spot.play.banner" id="53874263%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.spot.play.banner/index.html">de.mycrocast.android.sdk.spot.play.banner</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="53874263%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="1584429973%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.spot.play.data" id="1584429973%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.spot.play.data/index.html">de.mycrocast.android.sdk.spot.play.data</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="1584429973%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
<a data-name="144602931%2FPackages%2F1203251188" anchor-label="de.mycrocast.android.sdk.utility" id="144602931%2FPackages%2F1203251188" data-filterable-set=":library/release"></a>
    <div class="table-row" data-filterable-current=":library/release" data-filterable-set=":library/release">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="-mycrocast -s-d-k/de.mycrocast.android.sdk.utility/index.html">de.mycrocast.android.sdk.utility</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="144602931%2FPackages%2F1203251188"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag jvm-like">androidJvm</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
  </div>
</div>
    <div class="footer">
        <a href="#content" id="go-to-top-link" class="footer--button footer--button_go-to-top"></a>
        <span>© 2025 Copyright</span>
        <span class="pull-right">
            <span>Generated by </span>
            <a class="footer--link footer--link_external" href="https://github.com/Kotlin/dokka">
                <span>dokka</span>
            </a>
        </span>
    </div>
            </div>
        </div>
    </div>
</body>
</html>